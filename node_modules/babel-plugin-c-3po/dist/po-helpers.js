'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildPotData = buildPotData;
exports.applyReference = applyReference;
exports.applyExtractedComments = applyExtractedComments;
exports.makePotStr = makePotStr;
exports.parsePoData = parsePoData;
exports.getPluralFunc = getPluralFunc;
exports.getNPlurals = getNPlurals;
exports.hasTranslations = hasTranslations;
exports.isFuzzy = isFuzzy;
exports.pluralFnBody = pluralFnBody;
exports.makePluralFunc = makePluralFunc;
exports.getDefaultPoData = getDefaultPoData;
exports.hasUsefulInfo = hasUsefulInfo;

var _babelTypes = require('babel-types');

var bt = _interopRequireWildcard(_babelTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _gettextParser = require('gettext-parser');

var _gettextParser2 = _interopRequireDefault(_gettextParser);

var _defaults = require('./defaults');

var _dedent = require('dedent');

var _dedent2 = _interopRequireDefault(_dedent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function buildPotData(translations) {
    var data = {
        charset: 'UTF-8',
        headers: _defaults.DEFAULT_HEADERS,
        translations: {
            '': {}
        }
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = translations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var trans = _step.value;

            var ctx = trans[_defaults.PO_PRIMITIVES.MSGCTXT] || '';
            if (!data.translations[ctx]) {
                data.translations[ctx] = {};
            }

            if (!data.translations[ctx][trans.msgid]) {
                data.translations[ctx][trans.msgid] = trans;
                continue;
            }

            var oldTrans = data.translations[ctx][trans.msgid];

            // merge references
            if (oldTrans.comments && oldTrans.comments.reference && trans.comments && trans.comments.reference && !oldTrans.comments.reference.match(trans.comments.reference)) {
                oldTrans.comments.reference = oldTrans.comments.reference + '\n' + trans.comments.reference;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return data;
}

function applyReference(poEntry, node, filepath, location) {
    if (!poEntry.comments) {
        poEntry.comments = {};
    }

    var reference = null;

    switch (location) {
        case _defaults.LOCATION.FILE:
            reference = filepath;break;
        case _defaults.LOCATION.NEVER:
            reference = null;break;
        default:
            reference = filepath + ':' + node.loc.start.line;
    }

    poEntry.comments.reference = reference;
    return poEntry;
}

var tagRegex = {};
function applyExtractedComments(poEntry, nodePath, tag) {
    if (!poEntry.comments) {
        poEntry.comments = {};
    }

    var node = nodePath.node;

    if (!(bt.isStatement(node) || bt.isDeclaration(node))) {
        // Collect parents' comments
        //
        applyExtractedComments(poEntry, nodePath.parentPath, tag);
    }

    var comments = node.leadingComments;
    var transComments = comments ? comments.map(function (c) {
        return c.value;
    }) : [];
    if (tag) {
        if (!tagRegex[tag]) {
            tagRegex[tag] = new RegExp('^s*' + tag + 's*(.*?)s*$');
        }
        transComments = transComments.map(function (c) {
            return c.match(tagRegex[tag]);
        }).filter(function (match) {
            return Boolean(match);
        }).map(function (c) {
            return (0, _dedent2.default)(c[1]);
        });
    }

    if (transComments.length === 0) return;

    if (poEntry.comments.extracted) {
        poEntry.comments.extracted += '\n';
    } else {
        poEntry.comments.extracted = '';
    }
    poEntry.comments.extracted += transComments.join('\n');
}

function makePotStr(data) {
    return _gettextParser2.default.po.compile(data);
}

function parsePoData(filepath) {
    var poRaw = _fs2.default.readFileSync(filepath);
    var parsedPo = _gettextParser2.default.po.parse(poRaw.toString());
    var translations = parsedPo.translations;
    var headers = parsedPo.headers;
    return { translations: translations, headers: headers };
}

var pluralRegex = /\splural ?=?([\s\S]*);?/;
function getPluralFunc(headers) {
    try {
        var pluralFn = pluralRegex.exec(headers['plural-forms'])[1];
        if (pluralFn[pluralFn.length - 1] === ';') {
            pluralFn = pluralFn.slice(0, -1);
        }
        return pluralFn;
    } catch (err) {
        throw new Error('Failed to parse plural func from headers "' + JSON.stringify(headers) + '"\n');
    }
}

function getNPlurals(headers) {
    var nplurals = /nplurals ?= ?(\d)/.exec(headers['plural-forms'])[1];
    return parseInt(nplurals, 10);
}

function hasTranslations(translationObj) {
    return translationObj[_defaults.PO_PRIMITIVES.MSGSTR].reduce(function (r, t) {
        return r && t.length;
    }, true);
}

function isFuzzy(translationObj) {
    return translationObj && translationObj.comments && translationObj.comments.flag === 'fuzzy';
}

function pluralFnBody(pluralStr) {
    return 'return args[+ (' + pluralStr + ')];';
}

var fnCache = {};
function makePluralFunc(pluralStr) {
    /* eslint-disable no-new-func */
    var fn = fnCache[pluralStr];
    if (!fn) {
        fn = new Function('n', 'args', pluralFnBody(pluralStr));
        fnCache[pluralStr] = fn;
    }
    return fn;
}

function getDefaultPoData(headers) {
    return { headers: headers, translations: { '': {} } };
}

var nonTextRegexp = /\${.*?}|\d|\s|[.,\/#!$%\^&\*;:{}=\-_`~()]/g;
function hasUsefulInfo(text) {
    var withoutExpressions = text.replace(nonTextRegexp, '');
    return Boolean(withoutExpressions.match(/\S/));
}