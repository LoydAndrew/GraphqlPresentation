'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var context = void 0;
    var disabledScopes = new Set();
    var potEntries = [];

    function tryMatchTag(cb) {
        return function (nodePath, state) {
            var node = nodePath.node;
            if ((0, _gettextContext.isContextTagCall)(node, context) && (0, _gettextContext.isValidTagContext)(nodePath)) {
                nodePath._C3PO_GETTEXT_CONTEXT = node.tag.object.arguments[0].value;
                nodePath.node = bt.taggedTemplateExpression(node.tag.property, node.quasi);
                nodePath.node.loc = node.loc;
            }
            cb(nodePath, state);
        };
    }

    function tryMatchCall(cb) {
        return function (nodePath, state) {
            var node = nodePath.node;
            if ((0, _gettextContext.isContextFnCall)(node, context) && (0, _gettextContext.isValidFnCallContext)(nodePath)) {
                nodePath._C3PO_GETTEXT_CONTEXT = node.callee.object.arguments[0].value;
                nodePath.node = bt.callExpression(node.callee.property, node.arguments);
                nodePath.node.loc = node.loc;
            }
            cb(nodePath, state);
        };
    }

    function extractOrResolve(nodePath, state) {
        if (nodePath.node._C3PO_visited) {
            // Should visit each node only once
            return;
        }
        if ((0, _utils.isInDisabledScope)(nodePath, disabledScopes)) {
            return;
        }

        var extractor = (0, _extract.getExtractor)(nodePath, context);
        if (!extractor) {
            return;
        }

        var alias = context.getAliasFor(extractor.name);
        if (!context.hasImport(alias)
        // can be used in scope of context without import
        && !nodePath._C3PO_GETTEXT_CONTEXT) {
            return;
        }

        try {
            try {
                extractor.validate(nodePath.node, context);
            } catch (err) {
                if (err instanceof _errors.ValidationError) {
                    context.validationFailureAction(extractor.name, err.message);
                    return;
                }
                throw err;
            }

            if (context.isExtractMode()) {
                var poEntry = (0, _extract.extractPoEntry)(extractor, nodePath, context, state);
                poEntry && potEntries.push(poEntry);
            }

            if (context.isResolveMode()) {
                (0, _resolve.resolveEntries)(extractor, nodePath, context, state);
            }
            nodePath.node._C3PO_visited = true;
        } catch (err) {
            // TODO: handle specific instances of errors
            throw nodePath.buildCodeFrameError(err.message + '\n' + err.stack);
        }
    }

    return {
        post: function post() {
            if (context && context.isExtractMode() && potEntries.length) {
                var poData = (0, _poHelpers.buildPotData)(potEntries);

                // Here we sort reference entries, this could be useful
                // with conf. options extract.location: 'file' and sortByMsgid
                // which simplifies merge of .po files from different
                // branches of SCM such as git or mercurial.
                var ctxs = Object.keys(poData.translations);
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    var _loop = function _loop() {
                        var ctx = _step2.value;

                        var poEntries = poData.translations[ctx];
                        Object.keys(poEntries).forEach(function (k) {
                            var poEntry = poEntries[k];
                            // poEntry has a form:
                            // {
                            //     msgid: 'message identifier',
                            //     msgstr: 'translation string',
                            //     comments: {
                            //         reference: 'path/to/file.js:line_number\npath/to/other/file.js:line_number'
                            //     }
                            // }
                            if (poEntry.comments && poEntry.comments.reference) {
                                poEntry.comments.reference = poEntry.comments.reference.split('\n').sort(_utils.poReferenceComparator).join('\n');
                            }
                        });

                        if (context.isSortedByMsgid()) {
                            var oldPoData = poData.translations[ctx];
                            var newContext = {};
                            var keys = Object.keys(oldPoData).sort();
                            keys.forEach(function (k) {
                                newContext[k] = oldPoData[k];
                            });
                            poData.translations[ctx] = newContext;
                        }
                    };

                    for (var _iterator2 = ctxs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        _loop();
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                var potStr = (0, _poHelpers.makePotStr)(poData);
                var filepath = context.getOutputFilepath();
                var dirPath = _path2.default.dirname(filepath);
                _mkdirp2.default.sync(dirPath);
                _fs2.default.writeFileSync(filepath, potStr);
            }
        },

        visitor: {
            TaggedTemplateExpression: tryMatchTag(extractOrResolve),
            CallExpression: tryMatchCall(extractOrResolve),
            Program: function Program(nodePath, state) {
                if (!context) {
                    context = new _context2.default(state.opts);
                } else {
                    context.clear();
                }
                disabledScopes = new Set();
                if ((0, _utils.hasDisablingComment)(nodePath.node)) {
                    disabledScopes.add(nodePath.scope.uid);
                }
            },
            BlockStatement: function BlockStatement(nodePath) {
                if ((0, _utils.hasDisablingComment)(nodePath.node)) {
                    disabledScopes.add(nodePath.scope.uid);
                }
            },
            ImportDeclaration: function ImportDeclaration(nodePath) {
                var node = nodePath.node;

                if ((0, _utils.isC3poImport)(node)) {
                    node.specifiers.filter(function (_ref) {
                        var name = _ref.local.name;
                        return reverseAliases[name];
                    }).forEach(function (s) {
                        return context.addImport(s.local.name);
                    });
                }
                if ((0, _utils.isC3poImport)(node) && (0, _utils.hasImportSpecifier)(node)) {
                    node.specifiers.filter(bt.isImportSpecifier).filter(function (_ref2) {
                        var name = _ref2.imported.name;
                        return reverseAliases[name];
                    }).forEach(function (_ref3) {
                        var imported = _ref3.imported,
                            local = _ref3.local;

                        context.addAlias(reverseAliases[imported.name], local.name);
                        context.addImport(local.name);
                    });
                }
            }
        }
    };
};

var _babelTypes = require('babel-types');

var bt = _interopRequireWildcard(_babelTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _defaults = require('./defaults');

var _poHelpers = require('./po-helpers');

var _extract = require('./extract');

var _utils = require('./utils');

var _resolve = require('./resolve');

var _errors = require('./errors');

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

var _gettextContext = require('./gettext-context');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var reverseAliases = {};
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
    for (var _iterator = Object.keys(_defaults.ALIASES)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        reverseAliases[_defaults.ALIASES[key]] = key;
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally {
    try {
        if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
        }
    } finally {
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}