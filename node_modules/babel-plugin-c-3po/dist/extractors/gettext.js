'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _babelTypes = require('babel-types');

var t = _interopRequireWildcard(_babelTypes);

var _utils = require('../utils');

var _errors = require('../errors');

var _defaults = require('../defaults');

var _poHelpers = require('../po-helpers');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MSGSTR = _defaults.PO_PRIMITIVES.MSGSTR;

var NAME = 'gettext';

function getMsgid(node) {
    return node.arguments[0].value;
}

var validate = function validate(node) {
    var arg = node.arguments[0];
    if (!t.isLiteral(arg)) {
        throw new _errors.ValidationError('You can not use ' + arg.type + ' \'' + (0, _utils.ast2Str)(arg) + '\' as an argument to gettext');
    }
    if (arg.type === 'TemplateLiteral') {
        throw new _errors.ValidationError('You can not use template literal as an argument to gettext');
    }
    if (!(0, _poHelpers.hasUsefulInfo)(arg.value)) {
        throw new _errors.ValidationError('Can not translate \'' + arg.value + '\'');
    }
};

function match(node, context) {
    return t.isCallExpression(node) && t.isIdentifier(node.callee) && node.callee.name === context.getAliasFor(NAME) && node.arguments.length > 0;
}

function resolveDefault(node) {
    return node.arguments[0];
}

function resolve(node, translation) {
    var transStr = translation[MSGSTR][0];
    return t.stringLiteral(transStr);
}

exports.default = { match: match, resolve: resolve, resolveDefault: resolveDefault, validate: validate, name: NAME, getMsgid: getMsgid };